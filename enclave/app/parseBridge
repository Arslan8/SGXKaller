#!/usr/bin/python
import angr,claripy
import sys, getopt
import os.path
from random import randrange,shuffle
import string
import random
from cStringIO import StringIO
from IPython import embed
import time
import datetime
from subprocess import Popen
numFuncs = 0
doSymExec = False
startTime =0
parseTimeStart = 0
parseModelTime = 0
symExecTime = 0
parseClusterTime = 0
inferModelTime = 0
mainLoopStart = 0
totalExecs = 0
mystdout = StringIO()
x={}
m={}
unfuzzSnippet=[]
fuzzSnippet=[]
sizeMap={}
#
typedefs = {}
stDef = 0
debugPrint = 0
funcWritten = 0
parseBuf=[]
structs={}
aliases={}
funcWithRet = []
isEnum = False
current = None
results = None
seedTestcase = None 
ec = {}
targetFuncs= []
import subprocess
bestScore = 0
baselineScore = 0
bestIndex = 0
testcaseDir = ""
check = "if (ret != SGX_SUCCESS)\n	printf(\"Failure Code: %d\",ret); \n"
import signal
import sys
import struct

class sgx_is_within_enclave(angr.SimProcedure):
    def run(self):
        return 1

class abort(angr.SimProcedure):
    NO_RET = True
    def run(self):
        self.exit(1)

class sgx_lfence(angr.SimProcedure):
    def run(self):
        return

class sgx_is_outside_enclave(angr.SimProcedure):
    def run(self):
        return 1

class printf(angr.SimProcedure):
    def run(self):
        return

class sgx_ocall(angr.SimProcedure):
    def run(self):
        return 0

def signal_handler(sig, frame):
    results.write("Best score:" + str(bestScore) + " with testcase" +str(bestIndex) + "\n")
    results.write("Throughput stats: " +"\n")
    x = time.strptime('00:01:00,000'.split(',')[0],'%H:%M:%S')
    datetime.timedelta(hours=x.tm_hour,minutes=x.tm_min,seconds=x.tm_sec).total_seconds()
    timeElapsed = time.time() - startTime
    fuzzTime = time.time() - mainLoopStart
    results.write("Total Execs: " + str(totalExecs) + "\n")
    results.write("Througput:" + str(totalExecs/timeElapsed) +"\n")
    results.write("Throughtput Fuzzer: " + str(totalExecs/fuzzTime) + "\n")
    results.write("Parse Time: "+ str(parseTimeStart) +"\n")
    results.write("Total time elapsed: " + str(timeElapsed) +"\n")
    results.write("Symbolic Execution Time: " + str(symExecTime) +"\n")
    results.write("Infer Loop Time: " + str(inferModelTime) +"\n")
    results.write("Parse Model Time: " + str(parseModelTime) +"\n")
    sys.exit(0)

aliases={}
def parseStruct(parseBuf, anontag=""):
    members = parseBuf[1:-1]
    tag = parseBuf[0]
    #stdioPrint("Parsing :" + tag)
    temp= tag.replace("typedef ","").replace("{", "").rstrip()
    if temp == "struct" :
        #stdioPrint("Anonymous struct")
        tag = anontag
        temp = anontag
    structs[temp]={}
    if ("typedef" in tag):
        alias = parseBuf[-1].replace(";","").replace("}","").strip()
        tag= tag.replace("typedef ","").replace("{", "").rstrip()
        structs[tag]['alias'] = alias
        aliases[alias] = structs[tag]
        #scPrint( "Tag is:" + tag)
        #scPrint( "Alias is:" + alias)

    structs[tag]['numMembers']=len(members)
    structs[tag]['mem'] = {}
    tempbuf = []
    cont = False
    for member in members:
        #stdioPrint(member)
        if ("struct" in member and "{" in member):
            cont = True

        if (cont):
            tempbuf.append(member)
            if "}" in member:
                memName = member.replace("}","").replace(";","")
                cont = False
                structs[tag]['mem'][memName] = parseStruct(tempbuf,memName)
                structs[tag]['numMembers'] -= structs[tag]['mem'][memName]['numMembers'] 
                structs[tag]['numMembers'] -= 1 # For delimiters 
            continue
                
        typeName = member.split()
        structs[tag]['mem'][typeName[-1].replace(";","")] = " ".join(typeName[:-1])

    #scPrint(structs)
    return structs[tag]



def parsePrototype(proto):
    global stDef
    global debugPrint
    global parseBuf
    global isEnum
    words = proto.split()
    #scPrint(words)
    if "struct" in words or "union" in words or "enum" in words:
        func = False
        for word in words:
            if ");" in word:
                func=True
        if (not func):
            if "enum" in words:
                isEnum = True
            stDef += 1

    if (stDef > 0):
        parseBuf.append(proto)
    
    if "}" in proto and ";" in proto:
        stDef -= 1
    if (stDef > 0):
        debugPrint = True
        return
    elif (debugPrint  and stDef ==0):
        #scPrint(parseBuf)
        debugPrint = 0
        #completely parsed the struct definition
        #if isEnum:
        #    parseEnum(parseBuf)
        #    isEnum = False
        #else:
        #    parseStruct(parseBuf)
        parseStruct(parseBuf)
        parseBuf=[]
        return

    #this is an alias register it
    if "typedef" in proto:
        aliasTo = proto.split(' ')[-1].replace(";","")
        aliasFrom = proto.split(' ')[1:-1]
        arrSize = 0
        if ("[" in aliasTo):
            aliasTo, arr = aliasTo.split("[")
            arrSize = int(arr.replace("]",""))
        #scPrint(aliasTo)
        aliases[aliasTo] ={}
        aliases[aliasTo]["from"] = " ".join(aliasFrom)
        aliases[aliasTo]["arrSize"] = arrSize
        #scPrint(aliases)
        return

    #scPrint(proto)
    ret, proto = proto.split(' ', 1)
    name, proto = proto.split('(',1)
    #scPrint(name)
    name = name.strip()
    x[name]={}
    x[name]['ret'] = ret
    stdioPrint('Func Name:' + name)
    stdioPrint('return value:' + x[name]['ret'])
    argsJoined,_ = proto.split(');',1)
    #print 'Func Args:' + x['args']
    args = argsJoined.split(',')
    x[name]['numargs'] = len(args)
    i = 0;
    x[name]['args']= {}
    for arg in args:
        typeName = arg.split(' ')
        argtype,argname=typeName[:-1],typeName[-1]
        size = argname.split('[')
        isArr = False
        arrSize = 0
        if (len(size) == 2):
            arrSize = size[-1].split(']')[0]
            argname = size[0]
            isArr = True
        x[name]['args'][i] = {}
        x[name]['args'][i]['arrSize'] = arrSize
        x[name]['args'][i]['type'] = " ".join(argtype)
        x[name]['args'][i]['id'] = argname
#        if (isArr):
#            print 'Type:' +'Array of size' + arrSize+ 'of type'.join(argtype)
#        else:
#            print 'Type:' +''.join(argtype)
        i += 1
        #print 'Name:' + argname

    #print x[name]

def parseChain(chain):
    #print chain
    arg,chain=chain.split('->',1);
    firstarg = arg
#    print firstarg
    while(True):
        funcname,argnum = arg.split(":",1)
        nextarg,temp = chain.split('->',1)
        m[arg] = nextarg
        #print "Keying for: " + funcname + " " +argnum
        #print x[funcname]
        x[funcname]['args'][int(argnum)]['chain'] = firstarg
        #print x[funcname]['args'][int(argnum)]['chain']
        #print arg +'->'+ m[arg]
        if temp == "-|":
            #register node here though
            break
        #if (argnum.isdecimal()):
        arg,chain=chain.split('->',1);

def parseBridge(bridge):
    with open(bridge) as fp:
       line = fp.readline()
       while line:
           parsePrototype(line.strip())
           line = fp.readline()

def parseModel(model):
    with open(model) as fp:
       line = fp.readline()
       while line:
           parseChain(line.strip())
           line = fp.readline()

def randomString(stringLength):
    letters = string.ascii_letters
    return ''.join(random.choice(letters) for i in range(stringLength))

def printw(string):
    sys.stdout.write(string)


def make_unicode(input):
    if type(input) != unicode:
        input =  input.decode('utf-8')
    return input

def writeFunction(func, carg=[], cid="", retmap= {}, genRetVal=False):
    #print carg
    id=[]
    arr=""
    ret_val = ""
    #print cid
    for arg in x[func]['args']:
        #See if this arg is in chain 
        if(str(arg) in carg):
            if (cid !=""):
                id.append(cid)
                continue

        #See if arg is from another call's return 
        if(retmap.has_key(str(arg))):
            id.append(retmap[str(arg)])
            continue

        ast = x[func]['args'][arg]
        if (ast['type'] == 'sgx_enclave_id_t'):
            id.append( 'global_eid')
            continue
        id.append(randomString(10) + "_" + str(arg))
        #scPrint(ast['arrSize'])
        if ast['arrSize'] != 0:
            arr="[" + str(ast['arrSize']) + "]"
        else:
            arr=""
        print (ast['type'] + " " + id[arg] + arr + ";")
        if(str(arg) in carg):
            #print "Here"
            #See if this was the first time we wrote the chained variable
            cid = id[arg]
    if genRetVal:
        ret_val = randomString(10)
        print (x[func]['ret'] + " " +ret_val + ";")
    else:
        ret_val = "ret"

    printw (ret_val + " = ")
    
    printw (func + "(")
    printw (', '.join(map(str, id)))
    print(");")
    return cid,ret_val

def scPrint(obj):
    #sys.stdout= sys.__stdout__
    sys.stdout = current
    print (obj)
    current.flush()
    sys.stdout= mystdout


def stdioPrint(obj):
    old = sys.stdout 
    sys.stdout= sys.__stdout__
    print (obj)
    sys.stdout= old

def fuzz(snip, func):
    global x
    global seedTestcase
    global doSymExec
    typeName = snip.split(" ")
    type, id = typeName[:-1],typeName[-1]
    size = id.split('[');
    isArr = False
    arrSize = 0
    if (len(size) == 2):
        arrSize = size[-1].split(']')[0]
        id = size[0]
        isArr = True
    type = " ".join(type)
    #scPrint("Will fuzz "+ id + "for type " + type + " and array of size" + str(arrSize))

    #we fuzz based on the type
    type = type.strip()
    qualifier = ""
    if ("const " in type):
        qualifier = type.split("const ",1)[0]
        qualifier = qualifier + " const "
        type = type.split("const ",1)[1]
    id = id.replace(";","")
    sign = ["","-"]
    delim=["","",""]
    if (arrSize != 0):
        delim=["{","}","["+arrSize+"]"]
    else:
        arrSize=1 #Scalar Case
    val = []
    #let's take advantage of C weak type systems, all bigger values will be truncated
    # based on the memory bin
    intalias=["int","size_t", "char", "wchar_t","short","long", "uint32_t", "uint64_t", "const char", "sgx_status_t", "uint8_t"]
    ptr=["int *", "int*", "float *", "float*", "size_t*", "size_t *", "void *", "void*"]
    astType = type.split()
    needLog = True
    #stdioPrint(type)
    if(type in intalias):
        # generate a random int
        needLog = False
        scPrint(snip);
        ast = snip.split(" ")
        tid = ast[-1].replace(";","")
        #embed()
        l = int(tid.split("_")[-1])
        snip = ""
        #embed()
        if (len(tid.split("_")) ==2 and ("solns" in x[func])):
            scPrint("temp = (char *)&" + tid + ";")
            argn = int(tid.split("_")[-1])
            solns = len(x[func]["args"][argn]) - 3  # type, arrSize and identifier
            if solns != 0:
                if solns ==1:
                    pick = 0
                else:
                    pick = randrange(solns -1)
                BA = x[func]["args"][argn][str(pick)]
                idx =0
                scPrint("fgets(temp,"+ str(len(x[func]["args"][argn][str(pick)]))+ ", stdin);")
                BA = x[func]["args"][argn][str(pick)]
                for byte in BA:
                        if doSymExec:
                            seedTestcase.write(struct.pack('B',byte))
                        else:
                            seedTestcase.write(struct.pack('B',0))
    elif("*" in type):
        #scPrint(type)
        pointsto = type.replace("*", "")
        suffix = ""
        if (len(id.split("_")) == 2):
            #This is an argument
            suffix = "_" + id.split("_")[-1]
        tempid = randomString(10) + suffix 
        tempsnip = pointsto + " " + tempid + ";"
        if ("void" in type):
            tempsnip = "char " + tempid + "[" + str(random.randint(0,2048)) + "];"
        scPrint(fuzz(tempsnip, func))
        delim[0] = "&"
        sign[1] = ""#unsigned case
        #val.append(tempid)
        if (decision(0.2)):
            delim[0] = "NULL"
            tempid = ""
        val.append(tempid)
    elif(type == "float" or type == "double"):
        for idx in range(int(arrSize)):
            val.append(str(random.uniform(0, 3.4E+38)))
    #elif (type == "char *" or type == "char*" or type=="const char*" or type=="const char *"):
    #    for idx in range(int(arrSize)):
    #        length = random.randint(0, 16384);
    #        val.append("\"" + randomString(length) +"\"")
    elif (type in structs):
        rsnip =[snip] 
        #TODO: Enums could fail if we don't start from zero
        if ("enum" in type):
            snip = type + " " + id + " = " + str(random.randint(0,structs[type]["numMembers"])) + ";"
        else:
            snip = snip
            scPrint(snip)
            ast = snip.split(" ")
            scPrint("memset(&" + ast[1] +",0,sizeof("+ ast[0]+ "));")
            snip = ""
        needLog = False
    elif (type in aliases):
        #stdioPrint("Here")
        rsnip =[snip]
        #TODO: Enums could fail if we don't start from zero
        if ("enum" in type):
            snip = type + " " + id + " = " + str(random.randint(0,aliases[type]["numMembers"])) + ";"
        else:
            scPrint(snip)
            ast = snip.split(" ")
            tid = ast[1].replace(";","")
            l = int(tid.split("_")[-1])
            #embed()
            if (len(tid.split("_")) ==2 and ("solns" in x[func])):
                scPrint("temp = (char *)&" + tid + ";")
                argn = int(tid.split("_")[-1])
                solns = x[func]["solns"]
                if solns ==1:
                    pick = 0
                else:
                    pick = randrange(solns -1)
                #embed()
                BA = x[func]["args"][argn][str(pick)]
                idx =0

                scPrint("fgets(temp,"+ str(len(x[func]["args"][argn][str(pick)]))+ ", stdin);")
                for byte in BA:
                    if doSymExec:
                        seedTestcase.write(struct.pack('B',byte))
                    else:
                        seedTestcase.write(struct.pack('B',0))
                    idx+=1
            else:
                scPrint("memset(&" + ast[1].replace(";","") +",0,sizeof("+ ast[0]+ "));")
            snip = ""
        needLog = False
    else:
        #We don't populate built-in types
        stdioPrint(type + "didn't match anything")
        if (len(id.split("_")) ==2 and ("solns" in x[func])):
                scPrint(snip)
                snip =""
                scPrint("temp = (char *)&" + id + ";")
                argn = int(id.split("_")[-1])
                solns = x[func]["solns"]
                #embed()
                stdioPrint(func)
                stdioPrint(solns)
                if solns ==1:
                    pick = 0
                else:
                    pick = randrange(solns -1)
                #embed()
                BA = x[func]["args"][argn][str(pick)]
                idx =0
                scPrint("fgets(temp,"+ str(len(BA))+ ", stdin);")
                for byte in BA:
                    if doSymExec:
                        seedTestcase.write(struct.pack('B',byte))
                    else:
                        seedTestcase.write(struct.pack('B',0))
                    idx+=1

        else:
            snip = type + " " + id + delim[2] + ";"
        needLog = False

    if needLog:
        snip = qualifier + type + " " + id + delim[2] +" = " + delim[0] + sign[random.randint(0,1)] + ", ".join(val) + delim[1] +";"




    
    #scPrint(snip)
    return snip

clu={}
# Python function to print permutations of a given list
def permutation(lst):
    # If lst is empty then there are no permutations
    if len(lst) == 0:
        return []
    # If there is only one element in lst then, only
    # one permuatation is possible
    if len(lst) == 1:
        return [lst]
    # Find the permutations for lst if there are
    # more than 1 characters
    l = [] # empty list that will store current permutation
    # Iterate the input(lst) and calculate the permutation
    for i in range(len(lst)):
       m = lst[i]
       # Extract lst[i] or m from the list.  remLst is
       # remaining list
       remLst = lst[:i] + lst[i+1:]
       # Generating all permutations where m is first
       # element
       for p in permutation(remLst):
           l.append([m] + p)
    return l

def parseCluster(clfile):
    with open(clfile) as fp:
        line = fp.readline()
        while line:
            gstate,cluster = line.split(":")
            cluster = cluster.strip()
            cluster = cluster[:-1]
            cluster = cluster.split(",")
            for node in cluster:
                node = node.strip()
            clu[gstate] = permutation(cluster)
            line = fp.readline()


def writeFunctionWrapper(func):
   global mystdout
   global funcWritten
   inChain = False;
   #TODO: What if different arguments are in different chains?
   #print func
   #print x
   #If there's a chain cid, holds the identifier for the chained variable
   #it is automotically create by writeFunction for us with correct
   #type

   cid = ""
   stdioPrint(funcWritten)
   funcWritten +=1
   if funcWritten ==1:
        scPrint("char * temp = NULL;")
   for arg in x[func]['args']:
        if(x[func]['args'][arg].has_key('chain')):
            #print func
            #print arg
            #print m[x[func]['args'][arg]['chain']]
            print (cid)
            node = x[func]['args'][arg]['chain']
            exhausted = False
            while(m.has_key(node)):
                retmap={}
                #This check deals with nested calls in parameters
                if(not make_unicode(node.split(":",1)[1]).isnumeric()):
                    func, arg, nfunc, narg = node.split(":")
                    #print "Nested call for" + nfunc
                    cid,ret_val = writeFunction(nfunc,narg,cid,retmap,True)
                    retmap[arg] = ret_val
                carg = [node.split(":",1)[1]]
                name = node.split(":",1)[0]
                #Exhaust all the nodes in this call
                while (m.has_key(node) and m[node].split(":",1)[0] == name):
                    node = m[node]
                    #if nested call save the return value
                    if(not make_unicode(node.split(":",1)[1]).isnumeric()):
                       func,arg,nfunc,narg = node.split(":")
                       cid, ret_val =  writeFunction(nfunc,narg,cid,retmap,True)
                       retmap[arg] = ret_val
                    carg.append(node.split(":",1)[1])

                #populate pre-gen vars
                cid,_ = writeFunction(node.split(":",1)[0],carg,cid,retmap,False)
                #from IPython import embed; embed()
                if(m.has_key(node)):
                    node = m[node]
                else:
                    exhausted = True;
                    break
            if not exhausted:
                if(not make_unicode(node.split(":",1)[1]).isnumeric()):
                    func,arg,nfunc,narg = node.split(":")
                    #print "Nested call for" + nfunc
                    cid, ret_val =  writeFunction(nfunc,narg,cid,retmap,True)
                    retmap[arg] = ret_val
                    cid,_ = writeFunction(nfunc,narg,cid)
                carg = [node.split(":",1)[1]]
                writeFunction(node.split(":")[0],carg,cid,retmap,False)
            inChain = True
   if(inChain == False):
       writeFunction(func)

   unfuzzSnippet.append(mystdout.getvalue())
   #scPrint(unfuzzSnippet)
   unfuzzSnippetl = mystdout.getvalue().split("\n")
   for snip in unfuzzSnippetl:
       if snip and not "(" in snip:
           snip = fuzz(snip, func)
       scPrint(snip)
   mystdout = StringIO()
   sys.stdout= mystdout


def parseEDL(rawDat):
    last_edl = ""
    with open(rawDat) as fp:
        line = fp.readline()
        while line:
            #stdioPrint(line)
            line = line.strip()
            if ("EDL:" in line):
                edl = line.replace("EDL:","")
                #stdioPrint(edl)
                last_edl = edl
                if (not ec.has_key(last_edl)):
                    ec[edl]= set()
            else:
                #stdioPrint(line)
                #embed()
                ec[last_edl].add(line)
            line = fp.readline()


def writeClusters():
    for gstate in clu:
        i = 0
        for perm in clu[gstate]:
            filename = "./" + gstate + str(i)
            current = open("./" + gstate + str(i), "w")
            for func in perm:
                writeFunctionWrapper(func)
                current.flush()
            if (subprocess.call(["timeout", "1s", "./runperm.sh", filename, testcaseDir]) == 0):
                clu[gstate][i].insert(0,"GOOD")
            else:
                clu[gstate][i].insert(0,"BAD")
            i+=1


currPool = set()
def decision(probability):
    return random.random() < probability
lastAdded = ""
totalRunsSinceMe = 0
totalScoreSinceMe = 0

#OK After feedback it should really be adjust pool, because sometimes we don't increase
# the pool size, we just take out a badd API once in a while
def increasePool():
    global validElem
    global totalScoreSinceMe
    global totalRunsSinceMe
    global targetFuncs
    edls = len(validElem)
    if (decision(0.9)):
        edl = random.randint(0, edls- 1)
        targetFuncs = targetFuncs | ec[validElem[edl]]
    global lastAdded
    targetSize = len(targetFuncs)
    averageScoreSinceMe = totalScoreSinceMe/totalRunsSinceMe
    if (averageScoreSinceMe < baselineScore and lastAdded):
        #Get this testcase outta here
        currPool.remove(lastAdded)
    lastAdded = list(targetFuncs)[random.randint(0, targetSize - 1)]
    currPool.add(lastAdded)

baselineScore = 0

def getScore():
    global testcaseDir
    global totalExecs
    fname = testcaseDir + "/out/fuzz_trace_best"
    stat = testcaseDir + "/out/fuzzer_stats"
    virginBitsInv = testcaseDir + "/out/blockcoverage"
    numBlocks = 0
    numSet = 0
    blockHit = 0
    if(os.path.isfile(fname)):
        with open(fname) as f:
            for chunk in iter(lambda: f.read(4), b''):
                #print chunk
                if (len(chunk) != 4):
                    break
                num = struct.unpack('i', chunk)[0]
                for byte in range(3):
                    if (((num >> (byte * 8)) & 0xFF) > 0):
                        blockHit += 1
                numBlocks += 4

        with open(stat) as f:
            for line in f:
                line = line.rstrip()  # remove '\n' at end of line
                if "execs_done" in line:
                    totalExecs += int(line.split(":")[-1])


        with open(virginBitsInv) as f:
            for line in f:
                line = line.rstrip()
                blockHit = int(line.split(":")[-1])

        return blockHit
    else:
        stdioPrint("The testcase failed")
        return 0

def mainLoop():
    global current
    global startTime
    global currPool
    global baselineScore
    global bestIndex
    global bestScore
    global totalScoreSinceMe
    global totalRunsSinceMe
    global funcWritten
    global caseIndex
    global mainLoopStart
    global testcaseDir
    global seedTestcase
    mainLoopStart = time.time()
    currPool = set()
    targetSize = len(targetFuncs)
    caseIndex = 0
    weGood = False
    for func in targetFuncs:
        filename = "baseline"
        testcaseDir = "./work/" + filename
        seedFile = "./work/" + filename + "/in/1"
        filename = "./work/" + filename +"/" +filename
        funcWritten = 0
        subprocess.call(["timeout", "10s", "./setupHarness.sh", testcaseDir])
        current = open(filename, 'w+')
        seedTestcase = open(seedFile, 'wb+')
        writeFunctionWrapper(func)
        scPrint(check)
        seedTestcase.write(struct.pack('B',0))
        current.flush()
        seedTestcase.flush()
        subprocess.call(["timeout", "40s", "./runperm.sh", filename, testcaseDir])
        fname = "./work/baseline/out/fuzz_trace_best"
        if(os.path.isfile(fname)):
            currPool.add(func)
            weGood = True
            baselineScore = getScore()
            break
        subprocess.call(["sh", "./cleanup.sh"])
 
    if weGood:
        while True:
            #while True:
            #stdioPrint(currPool)
            currPermutation = list(currPool)
            shuffle(currPermutation)
            #stdioPrint(currPermutation)
            filename = "testcase"+ str(caseIndex)
            testcaseDir = "./work/" + filename
            seedFile = "./work/" + filename + "/in/1"
            filename = "./work/" + filename +"/" +filename
            subprocess.call(["timeout", "10s", "./setupHarness.sh", testcaseDir])
            funcWritten =0
            current = open(filename, 'w+')
            seedTestcase = open(seedFile, 'wb+')
            for func in currPermutation:
                writeFunctionWrapper(func)
                scPrint(check)
                current.flush()
                seedTestcase.flush()
            seedTestcase.write(struct.pack('B',0))
            seedTestcase.flush()
            subprocess.call(["timeout", "40s", "./runperm.sh", filename, testcaseDir])
            currentScore = getScore()
            if (currentScore == 0):
                results.write(filename + " might've crashed or hanged \n")
            stdioPrint(currentScore)
            subprocess.call(["sh", "./cleanup.sh"])

            #Bookeeping
            totalScoreSinceMe += currentScore
            totalRunsSinceMe += 1
            if (currentScore > bestScore):
                bestScore = currentScore
                bestIndex = caseIndex
                results.write(str(time.time()- startTime)+": " + str(bestScore) + "\n")
            caseIndex += 1
            #Probabilty to increase the pool size
            if (decision(0.9)):
                increasePool()
validElem = []
def inferModel():
    global current
    global startTime
    global currPool
    global baselineScore
    global bestIndex
    global bestScore
    global totalScoreSinceMe
    global totalRunsSinceMe
    global funcWritten
    global caseIndex
    global mainLoopStart
    global testcaseDir
    global seedTestcase
    global targetFuncs
    global validElem
    global numFuncs
    for elem in (list(ec)):
        if (len(ec[elem])):
            validElem.insert(0,elem)

    edls = len(validElem)


    if (numFuncs > 7):
        while True:
            edl = random.randint(0, edls- 1)
            stdioPrint(validElem[edl])
            targetFuncs = ec[validElem[edl]]
            mainLoop()
    else:
        #Write all the permuatations, less than 4 we have 24 permutations
        caseIndex = 0
        edl = 0
        while edl < edls:
            #embed()
            perms = permutation(list(ec[validElem[edl]]))
            proc = []
            #stdioPrint(currPermutation)
            for currPermutation in perms:
                filename = "testcase"+ str(caseIndex)
                testcaseDir = "./work/" + filename
                seedFile = "./work/" + filename + "/in/1"
                filename = "./work/" + filename +"/" +filename
                subprocess.call(["./setupHarnessEx.sh", testcaseDir])
                funcWritten =0
                current = open(filename, 'w+')
                seedTestcase = open(seedFile, 'wb+')
                for func in currPermutation:
                    writeFunctionWrapper(func)
                    scPrint(check)
                    current.flush()
                    seedTestcase.flush()
                seedTestcase.write(struct.pack('B',0))
                seedTestcase.flush()
                subprocess.call(["./setupHarnessPost.sh", filename, testcaseDir])
                proc.append(Popen(["./runperm.sh", filename, testcaseDir]))
                caseIndex += 1
            edl += 1

        while True:
            i =0


        
     

    stdioPrint(targetFuncs)

def parseRet(ret):
      with open(ret) as fp:
         line = fp.readline()
         while line:
             funcWithRet.append(line.replace("\n", ""))
             line = fp.readline()
def _symExec(csm):
    stepCount = 100
    while len(csm.active) > 0 and stepCount >0:
        #stdioPrint(csm)
        csm.step()
        stepCount -= 1
idc =0
def argToBV(arg):
    global idc
    global current
    stdioPrint(arg)
    val = claripy.BVS('val' + str(idc), 32)
    type = arg['type']
    if type in sizeMap:
        size = sizeMap[type]
    else:
        filename = "./temp"
        current = open(filename, 'w+')
        typeFiltered = type.replace("*","")
        scPrint("printf(\"SGXFUZZLOGS:%d\\n\", sizeof("+ typeFiltered+")); \n")
        subprocess.call(["timeout", "25s", "./getSize.sh"])
        fname = "./log"
        if(os.path.isfile(fname)):
            with open(fname) as fp:
                line = fp.readline()
                while line:
                    if "SGXFUZZLOGS" in line:
                        size = line.replace("SGXFUZZLOGS:", "")
                        break
                    line = fp.readline()
        else:
            stdioPrint("Could not file FATAL failure")
        stdioPrint('val' + str(idc) + size)
        sizeMap[type] = size
        val = claripy.BVS('val' + str(idc), int(size) * 8)
    if '*' in type:
        val = angr.PointerWrapper(val)
        stdioPrint("Wrapped")
    idc +=1
    return val

def getBV(arg):
    if not type(arg) == claripy.ast.bv.BV:
        arg = arg.value
    return arg

def getSolns(arg, csm, func, skipArg):
    x[func]['solns'] = len(csm.deadended)
    path = 0
    for deadended in csm.deadended:
        arg = getBV(arg)
        byte =0
        spath = str(path)
        x[func]['args'][0 + skipArg][spath] = []
        for chunk in arg.chop(8):
            x[func]['args'][0 + skipArg][spath].append(deadended.solver.eval(chunk))
            stdioPrint(x[func]['args'][0 + skipArg][spath][byte])
            byte +=1
        path += 1
    if x[func]['solns'] == 0:
        #IF we aren't able to find anything just memset args
        x[func]['solns'] = 1
        arg = getBV(arg)
        byte =0
        spath = str(path)
        x[func]['args'][0 + skipArg][spath] = []
        for chunk in arg.chop(8):
            x[func]['args'][0 + skipArg][spath].append(0)
            stdioPrint(x[func]['args'][0 + skipArg][spath][byte])
            byte +=1
        path += 1


def symExec(enclave):
    stdioPrint("enclave" + enclave)
    proj = angr.Project(enclave)
    state = proj.factory.entry_state()
    sm = proj.factory.simulation_manager(state)
    sm = proj.factory.simulation_manager(state)
    addr= proj.loader.find_symbol("sgx_is_within_enclave").relative_addr + proj.loader.min_addr
    proj.hook(addr, sgx_is_within_enclave())
    proj.hook_symbol("abort", abort())
    proj.hook_symbol("sgx_lfence", sgx_lfence())
    proj.hook_symbol("sgx_is_outside_enclave", sgx_is_outside_enclave())
    proj.hook_symbol("printf", printf())
    proj.hook_symbol("sgx_ocall", sgx_ocall())
    cfg = proj.analyses.CFGFast()
    cfg.normalize()
    for func in x:
        addr= cfg.kb.functions[func].addr
        stdioPrint(addr)
        stdioPrint(func)
        nargs = x[func]['numargs']
        skipArg = 1
        if func in funcWithRet:
            skipArg +=1
        stdioPrint(x[func]['numargs'] - skipArg)
        nargs -= skipArg
        if nargs == 0:
            cs = proj.factory.call_state(addr)
            csm = proj.factory.simgr(cs,veritesting=False)
            _symExec(csm)
        elif nargs == 1:
            arg0 = argToBV(x[func]['args'][0 + skipArg])
            cs = proj.factory.call_state(addr, arg0)
            csm = proj.factory.simgr(cs,veritesting=False)
            _symExec(csm)
            getSolns(arg0, csm, func, 0+skipArg)

        elif nargs == 2:
            arg0 = argToBV(x[func]['args'][0 + skipArg])
            arg1 = argToBV(x[func]['args'][1 + skipArg])
            cs = proj.factory.call_state(addr, arg0, arg1)
            csm = proj.factory.simgr(cs,veritesting=False)
            _symExec(csm)
            getSolns(arg0, csm, func, 0+skipArg)
            getSolns(arg1, csm, func, 1+skipArg)
            #embed()

        elif nargs == 3:
            arg0 = argToBV(x[func]['args'][0 + skipArg])
            arg1 = argToBV(x[func]['args'][1 + skipArg])
            arg2 = argToBV(x[func]['args'][2 + skipArg])
            cs = proj.factory.call_state(addr, arg0, arg1, arg2)
            csm = proj.factory.simgr(cs,veritesting=False)
            _symExec(csm)
            getSolns(arg0, csm, func, 0+skipArg)
            getSolns(arg1, csm, func, 1+skipArg)
            getSolns(arg2, csm, func, 2+skipArg)

        elif nargs == 4:
            arg0 = argToBV(x[func]['args'][0 + skipArg])
            arg1 = argToBV(x[func]['args'][1 + skipArg])
            arg2 = argToBV(x[func]['args'][2 + skipArg])
            arg3 = argToBV(x[func]['args'][3 + skipArg])
            cs = proj.factory.call_state(addr, arg0, arg1, arg2)
            csm = proj.factory.simgr(cs,veritesting=False)
            _symExec(csm)
            getSolns(arg0, csm, func, 0+ skipArg)
            getSolns(arg1, csm, func, 1+skipArg)
            getSolns(arg2, csm, func, 2+skipArg)
            getSolns(arg3, csm, func, 3+skipArg)

        elif nargs == 5:
            arg0 = argToBV(x[func]['args'][0 + skipArg])
            arg1 = argToBV(x[func]['args'][1 + skipArg])
            arg2 = argToBV(x[func]['args'][2 + skipArg])
            arg3 = argToBV(x[func]['args'][3 + skipArg])
            arg4 = argToBV(x[func]['args'][4 + skipArg])
            cs = proj.factory.call_state(addr, arg0, arg1, arg2)
            csm = proj.factory.simgr(cs,veritesting=False)
            _symExec(csm)
            getSolns(arg0, csm, func, 0+skipArg)
            getSolns(arg1, csm, func, 1+skipArg)
            getSolns(arg2, csm, func, 2+skipArg)
            getSolns(arg3, csm, func, 3+skipArg)
            getSolns(arg4, csm, func, 4+skipArg)
        elif nargs==6:
            arg0 = argToBV(x[func]['args'][0 + skipArg])
            arg1 = argToBV(x[func]['args'][1 + skipArg])
            arg2 = argToBV(x[func]['args'][2 + skipArg])
            arg3 = argToBV(x[func]['args'][3 + skipArg])
            arg4 = argToBV(x[func]['args'][4 + skipArg])
            arg5 = argToBV(x[func]['args'][5 + skipArg])
            cs = proj.factory.call_state(addr, arg0, arg1, arg2, arg3, arg4, arg5)
            csm = proj.factory.simgr(cs,veritesting=False)
            _symExec(csm)
            getSolns(arg0, csm, func, 0+skipArg)
            getSolns(arg1, csm, func, 1+skipArg)
            getSolns(arg2, csm, func, 2+skipArg)
            getSolns(arg3, csm, func, 3+skipArg)
            getSolns(arg4, csm, func, 4+skipArg)
            getSolns(arg5, csm, func, 5+skipArg)
        elif nargs==7:
            arg0 = argToBV(x[func]['args'][0 + skipArg])
            arg1 = argToBV(x[func]['args'][1 + skipArg])
            arg2 = argToBV(x[func]['args'][2 + skipArg])
            arg3 = argToBV(x[func]['args'][3 + skipArg])
            arg4 = argToBV(x[func]['args'][4 + skipArg])
            arg5 = argToBV(x[func]['args'][5 + skipArg])
            arg6 = argToBV(x[func]['args'][6 + skipArg])
            cs = proj.factory.call_state(addr, arg0, arg1, arg2, arg3, arg4, arg5, arg6)
            csm = proj.factory.simgr(cs,veritesting=False)
            _symExec(csm)
            getSolns(arg0, csm, func, 0+skipArg)
            getSolns(arg1, csm, func, 1+skipArg)
            getSolns(arg2, csm, func, 2+skipArg)
            getSolns(arg3, csm, func, 3+skipArg)
            getSolns(arg4, csm, func, 4+skipArg)
            getSolns(arg5, csm, func, 5+skipArg)
            getSolns(arg6, csm, func, 6+skipArg)
        elif nargs==8:
            arg0 = argToBV(x[func]['args'][0 + skipArg])
            arg1 = argToBV(x[func]['args'][1 + skipArg])
            arg2 = argToBV(x[func]['args'][2 + skipArg])
            arg3 = argToBV(x[func]['args'][3 + skipArg])
            arg4 = argToBV(x[func]['args'][4 + skipArg])
            arg5 = argToBV(x[func]['args'][5 + skipArg])
            arg6 = argToBV(x[func]['args'][6 + skipArg])
            arg7 = argToBV(x[func]['args'][7 + skipArg])
            cs = proj.factory.call_state(addr, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7)
            csm = proj.factory.simgr(cs,veritesting=False)
            _symExec(csm)
            getSolns(arg0, csm, func, 0+skipArg)
            getSolns(arg1, csm, func, 1+skipArg)
            getSolns(arg2, csm, func, 2+skipArg)
            getSolns(arg3, csm, func, 3+skipArg)
            getSolns(arg4, csm, func, 4+skipArg)
            getSolns(arg5, csm, func, 5+skipArg)
            getSolns(arg6, csm, func, 6+skipArg)
            getSolns(arg7, csm, func, 7+skipArg)
        elif nargs==9:
            arg0 = argToBV(x[func]['args'][0 + skipArg])
            arg1 = argToBV(x[func]['args'][1 + skipArg])
            arg2 = argToBV(x[func]['args'][2 + skipArg])
            arg3 = argToBV(x[func]['args'][3 + skipArg])
            arg4 = argToBV(x[func]['args'][4 + skipArg])
            arg5 = argToBV(x[func]['args'][5 + skipArg])
            arg6 = argToBV(x[func]['args'][6 + skipArg])
            arg7 = argToBV(x[func]['args'][7 + skipArg])
            arg8 = argToBV(x[func]['args'][8 + skipArg])
            cs = proj.factory.call_state(addr, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)
            csm = proj.factory.simgr(cs,veritesting=False)
            _symExec(csm)
            getSolns(arg0, csm, func, 0+skipArg)
            getSolns(arg1, csm, func, 1+skipArg)
            getSolns(arg2, csm, func, 2+skipArg)
            getSolns(arg3, csm, func, 3+skipArg)
            getSolns(arg4, csm, func, 4+skipArg)
            getSolns(arg5, csm, func, 5+skipArg)
            getSolns(arg6, csm, func, 6+skipArg)
            getSolns(arg7, csm, func, 7+skipArg)
            getSolns(arg8, csm, func, 8+skipArg)

def main(argv):
   global current
   global results
   global parseTimeStart 
   global parseModelTime 
   global symExecTime 
   global parseClusterTime 
   global inferModelTime
   global startTime
   global numFuncs
   startTime = time.time()
   inputfile = ''
   enclave = ''
   stDef = 0
   try:
       opts, args = getopt.getopt(argv,"hi:m:e:r:s:t:",["ifile="])
   except getopt.GetoptError:
      print ('Usage is wrong, please see main for usage')
      sys.exit(2)
   for opt, arg in opts:
      if opt == '-h':
         print ('test.py -i <inputfile> -o <outputfile>')
         sys.exit()
      elif opt in ("-i", "--ifile"):
         inputfile = arg
      elif opt in ("-m"):
         modelFile = arg
      elif opt in ("-e"):
         clusterFile = arg
      elif opt in ("-r"):
         rawDat = arg
      elif opt in ("-s"):
         enclave = arg
      elif opt in ("-t"):
         ret = arg
        

   # We want to handle the signal handling ourselves so we can print out stats in the end
   # TODO: Much better to just dump it in a file 
   signal.signal(signal.SIGINT, signal_handler)
   #scPrint("")
   path = "./work"
   if (os.path.isdir(path)):
       stdioPrint("Existing work Directory Found, Please cache previous work! \n")
       quit()
   os.mkdir(path)
   current = open("temp","w")
   results = open("./work/results", "w")
   parseTimeStart = time.time()
   parseEDL(rawDat)
   #stdioPrint(ec)
   parseBridge(inputfile)
   parseRet(ret)
   stdioPrint(x)
   parseTimeStart = time.time() - parseTimeStart
   stdioPrint(funcWithRet)
   parseModelTime = time.time();
   parseModel(modelFile)
   parseModelTime = time.time() - parseModelTime
   parseClusterTime = time.time()
   parseCluster(clusterFile)
   parseClusterTime = time.time() - parseClusterTime
   symExecTime = time.time()
   symExec(enclave)
   symExecTime = time.time() - symExecTime
   stdioPrint(x)
   #embed()
   #return
   #stdioPrint(m)
   #stdioPrint(x)
   #stdioPrint("Post parsing prints")
   #stdioPrint(structs["struct sgxsd_request_negotiation_response"])
   #func = "sgxsd_enclave_server_stop"
   #stdioPrint(x[func])
   #current = open("./temp", 'w+')
   #writeFunctionWrapper(func)
   # Uncomment the following line if you just want to run symbolic execution 
   #return 
   lx = list(x)
   numFuncs = len(lx)
   func = lx[randrange(numFuncs)]
   #stdioPrint(clu)
   #stdioPrint(list(ec))
   writeClusters()
   inferModelTime = time.time()
   inferModel() 
   inferModelTime = time.time() - inferModeTime 
    
if __name__ == "__main__":
   if len(sys.argv) > 2:
       main(sys.argv[1:])
